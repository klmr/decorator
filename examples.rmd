# Decorator examples

This file contains some example decorators and their usage.

```{r message=FALSE}
import('decorate', attach = TRUE)
```

## Defining decorators

In the first instance, we will define some decorators. To start off, here’s an
easy one (that’s admittedly a bit useless) — it just executes the decorated
function twice:

```{r}
#' Call decorated function twice, in succession
twice = decorator %@% function (f) {
    function (...) {
        f(...)
        f(...)
    }
}
```

The following decorator is more useful — it logs function calls.

```{r}
#' Log each call to the decorated function
#' @param file the file to log to (can be a file name or descriptor)
logged = function (file) decorator %@% function (f) {
    function (...) {
        cat(deparse(match.call()), '\n', file = file, append = TRUE)
        f(...)
    }
}
```

And finally, here’s a decorator that improves the syntax of a core function,
`.Deprecated`. `.Deprecated` belongs to a class of functions that provide meta
“type information” about the code, rather than having direct semantics. Such
functions are better suited as decorators.

```{r}
#' Mark a function as deprecated
#' @param new character string suggesting a replacement function
deprecated = function (new) decorator %@% function (f) {
    function (...) {
        call = deparse(sys.call()[[1]])
        .Deprecated(new, old = call)
        f(...)
    }
}
```

## Using decorators

The following function uses two decorators at once:

```{r}
echo = logged(stdout()) %@% twice %@% function (msg)
    message(msg)

echo('Hello, echo')
```

In the above, the first output comes from the `logged` call; the subsequent
output was generated by the function `echo` itself — doubled by `twice`.

Outputting the function definition shows us information about the decorators:

```{r}
echo
```

Let’s define and call a deprecated function:

```{r}
double = deprecated('2 * x') %@% function (x)
    2 * x

double(5)
```

## Outlook

One of the most interesting uses of decorators in Python is arguably the web
framework [Flask][]. Flask allows writing web applications where every route
(roughly, a URL) is handled by a distinct function call, optionally with
arguments:

```python
from flask import Flask

app = Flask(__name__)

@app.route('/<name>')
def hello(name):
    return 'Hello {}'.format(name)

if __name__ == '__main__':
    app.run()
```

Using decorators in conjunction with the [sys module][sys], it’s trivial to port
this code over to R almost line by line:

```r
sys = import('sys')
flask = import('flask')

hello = flask$route('/<name>') %@% function (name)
    sprintf('Hello %s', name)

sys$run(flask$run(module_name()))
```

[Flask]: http://flask.pocoo.org/
[sys]: https://github.com/klmr/sys
